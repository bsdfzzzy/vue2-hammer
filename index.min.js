"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.VueHammer = void 0;

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _hammerjs = _interopRequireDefault(require("hammerjs"));

var gestures = ['tap', 'pan', 'pinch', 'press', 'rotate', 'swipe'];
var subGestures = ['panstart', 'panend', 'panmove', 'pancancel', 'pinchstart', 'pinchmove', 'pinchend', 'pinchcancel', 'pinchin', 'pinchout', 'pressup', 'rotatestart', 'rotatemove', 'rotateend', 'rotatecancel'];
var directions = ['up', 'down', 'left', 'right', 'horizontal', 'vertical', 'all'];
var VueHammer = {
  config: {},
  customEvents: {},
  install: function install(Vue) {
    var _this = this;

    Vue.directive('hammer', {
      bind: function bind(el, binding) {
        if (!el.hammer) {
          el.hammer = new _hammerjs["default"].Manager(el);
        }

        var mc = el.hammer; // determine event type

        var event = binding.arg;

        if (!event) {
          console.warn('[vue-hammer] event type argument is required.');
        }

        el.__hammerConfig = el.__hammerConfig || {};
        el.__hammerConfig[event] = {};
        var direction = binding.modifiers;
        el.__hammerConfig[event].direction = el.__hammerConfig[event].direction || [];

        if ((0, _keys["default"])(direction).length) {
          var _context, _context2;

          (0, _forEach["default"])(_context = (0, _filter["default"])(_context2 = (0, _keys["default"])(direction)).call(_context2, function (keyName) {
            return binding.modifiers[keyName];
          })).call(_context, function (keyName) {
            var elDirectionArray = el.__hammerConfig[event].direction;

            if ((0, _indexOf["default"])(elDirectionArray).call(elDirectionArray, keyName) === -1) {
              elDirectionArray.push(String(keyName));
            }
          });
        }

        var recognizerType, recognizer;

        if (_this.customEvents[event]) {
          // custom event
          var custom = _this.customEvents[event];
          recognizerType = custom.type;
          recognizer = new _hammerjs["default"][_this.capitalize(recognizerType)](custom);
          recognizer.recognizeWith(mc.recognizers);
          mc.add(recognizer);
        } else {
          // built-in event
          recognizerType = (0, _find["default"])(gestures).call(gestures, function (gesture) {
            return gesture === event;
          });
          var subGesturesType = (0, _find["default"])(subGestures).call(subGestures, function (gesture) {
            return gesture === event;
          });

          if (!recognizerType && !subGesturesType) {
            console.warn('[vue-hammer] invalid event type: ' + event);
            return;
          }

          if (subGesturesType && el.__hammerConfig[subGesturesType].direction.length !== 0) {
            console.warn('[vue-hammer] ' + subGesturesType + ' should not have directions');
          }

          if (!recognizerType) {
            return;
          }

          if (recognizerType === 'tap' || recognizerType === 'pinch' || recognizerType === 'press' || recognizerType === 'rotate') {
            if (el.__hammerConfig[recognizerType].direction.length !== 0) {
              throw Error('[vue-hammer] ' + recognizerType + ' should not have directions');
            }
          }

          recognizer = mc.get(recognizerType);

          if (!recognizer) {
            // add recognizer
            recognizer = new _hammerjs["default"][_this.capitalize(recognizerType)](); // make sure multiple recognizers work together...

            recognizer.recognizeWith(mc.recognizers);
            mc.add(recognizer);
          } // apply global options


          var globalOptions = _this.config[recognizerType];

          if (globalOptions) {
            _this.guardDirections(globalOptions);

            recognizer.set(globalOptions);
          } // apply local options


          var localOptions = el.hammerOptions && el.hammerOptions[recognizerType];

          if (localOptions) {
            _this.guardDirections(localOptions);

            recognizer.set(localOptions);
          }
        }
      },
      inserted: function inserted(el, binding) {
        var mc = el.hammer;
        var event = binding.arg;
        var eventWithDir = (0, _find["default"])(subGestures).call(subGestures, function (subGes) {
          return subGes === event;
        }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction);

        if (mc.handler) {
          mc.off(eventWithDir, mc.handler);
        }

        if (typeof binding.value !== 'function') {
          mc.handler = null;
          console.warn('[vue-hammer] invalid handler function for v-hammer: ' + binding.arg);
        } else {
          mc.on(eventWithDir, mc.handler = binding.value);
        }
      },
      componentUpdated: function componentUpdated(el, binding) {
        var mc = el.hammer;
        var event = binding.arg;
        var eventWithDir = (0, _find["default"])(subGestures).call(subGestures, function (subGes) {
          return subGes === event;
        }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction); // teardown old handler

        if (mc.handler) {
          mc.off(eventWithDir, mc.handler);
        }

        if (typeof binding.value !== 'function') {
          mc.handler = null;
          console.warn('[vue-hammer] invalid handler function for v-hammer: ' + binding.arg);
        } else {
          mc.on(eventWithDir, mc.handler = binding.value);
        }
      },
      unbind: function unbind(el, binding) {
        var mc = el.hammer;
        var event = binding.arg;
        var eventWithDir = (0, _find["default"])(subGestures).call(subGestures, function (subGes) {
          return subGes === event;
        }) ? event : _this.buildEventWithDirections(event, el.__hammerConfig[event].direction);

        if (mc.handler) {
          el.hammer.off(eventWithDir, mc.handler);
        }

        if (!(0, _keys["default"])(mc.handlers).length) {
          el.hammer.destroy();
          el.hammer = null;
        }
      }
    });
  },
  guardDirections: function guardDirections(options) {
    var dir = options.direction;

    if (typeof dir === 'string') {
      var hammerDirection = 'DIRECTION_' + dir.toUpperCase();

      if ((0, _indexOf["default"])(directions).call(directions, dir) > -1 && _hammerjs["default"].hasOwnProperty(hammerDirection)) {
        options.direction = _hammerjs["default"][hammerDirection];
      } else {
        console.warn('[vue-hammer] invalid direction: ' + dir);
      }
    }
  },
  buildEventWithDirections: function buildEventWithDirections(eventName, directionArray) {
    var f = {};
    (0, _forEach["default"])(directionArray).call(directionArray, function (dir) {
      dir = dir.toLowerCase();

      if (dir === 'horizontal') {
        f.left = 1;
        f.right = 1;
      } else if (dir === 'vertical') {
        f.up = 1;
        f.down = 1;
      } else if (dir === 'all') {
        f.left = 1;
        f.right = 1;
        f.up = 1;
        f.down = 1;
      } else {
        f[dir] = 1;
      }
    });

    var _directionArray = (0, _keys["default"])(f);

    if (_directionArray.length === 0) {
      return eventName;
    }

    var eventWithDirArray = (0, _map["default"])(_directionArray).call(_directionArray, function (dir) {
      return eventName + dir;
    });
    return eventWithDirArray.join(' ');
  },
  capitalize: function capitalize(str) {
    return str.charAt(0).toUpperCase() + (0, _slice["default"])(str).call(str, 1);
  }
};
exports.VueHammer = VueHammer;
